#!/usr/bin/perl -w

# Wed Jun 24 16:42:42 EDT 2009
(my $email='chrjae@gmail.com')=~ tr/%,/@./;

use strict;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/lib";
our $stationsfile= "$mydir/stations.pl";

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname radioname

  Instead of radionname, give -l to get listing of all known radionames.

  Radioname can be part of the key given in -l, split on the
  underscore or digit and alphabetic character parts, or prefixes
  thereof, as long as there's no conflict.

  Options:
  -l|--list  list known station keys
  --dry-run  only select station, don't open it
  -m|--mono  mix to a single channel (only works with mpg123 for now)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our ($opt_l,$opt_dry);
our $opt_mono;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "list"=>\$opt_l,
	   "dry-run"=> \$opt_dry,
	   "mono"=> \$opt_mono,
	   ) or exit 1;
usage unless @ARGV==1 or $opt_l;
our ($rawkey)=@ARGV;

#use Chj::xperlfunc 'xexec';
sub xexec {
    #local $^W;
    no warnings;
    exec @_;
    die "xexec ".join(" ",@_).": $!";
}
use Tree::Trie;

our $run=sub {
    our ($cmd,@args)=@_;
    xexec (@$cmd,@args)
};

our $mkplayer= sub {
    my ($player,$maybe_playername)=@_;
    my $playername= $maybe_playername || $$player[0];
    sub {
	@_ == 2 or die "expecting 2 arguments";
	my ($key,$url)=@_;
	(lc($key),
	 sub {
	     if ($opt_dry) {
		 print "Would play $key ($url) with $playername.\n";
	     } else {
		 my $msg= "*** Playing $key ($url) with $playername ***";
		 my $line= "*"x(length($msg));
		 print "$line\n$msg\n$line\n";
		 &$run ($player,$url)
	     }
	 }
	)
    }
};

sub mms; sub mp3; sub ogg; # to avoid "used only once" warnings.

*mms=
    &$mkplayer (["mplayer",
		 #"-audio-preload","2"  is in mplayer manpage, but is for mencoder only.
		 #hm finde nix
		]);
sub mplayer; *mplayer= \&mms;
sub aacplus; *aacplus= \&mplayer;

*mp3=
    &$mkplayer (["mpg123", ($opt_mono ? "-m" : ())]);
*ogg=
    &$mkplayer (["ogg123",
		 "-b","180",#
		 "-p","90",
		 "--audio-buffer","1000",#
		 #^ well shouldn't it be 10 times bigger than the input...
		]);

#our $mapping= require $stationsfile;
our $mapping= eval qq[#line 1 "$stationsfile"\n +{\n].do {
    open my $in, "<",$stationsfile;
    local $/;
    my $cnt= <$in>;
    close $in or die;
    $cnt
}."\n}";
die $@ if $@;


sub Die {
    die join("", "$myname: ",@_, "\n")
}

sub filter_singles ( $ ) { # array of pairs -> hash containing only those pairs which appear once
    # [ [ "a", 1 ], [ "a", 2 ], [ "b", 3 ] ] -> { "b" => 3 }
    my ($lis)=@_;
    my $seen= {};
    my $out= {};
    for (@$lis) {
	my ($key,$val)=@$_;
	if ($$seen{$key}) {
	    delete $$out{$key}; # in case we had something
	} else {
	    $$seen{$key}=1;
	    $$out{$key}=$val;
	}
    }
    $out
}

if ($opt_l) {
    print map { "$_\n" } sort keys %$mapping
} else {
    {
	# first try to add the parts split on _, then split on number boundaries;
	local our $add_keys_singles= sub {
	    local our $filtered= filter_singles \@_;
	    for my $part (keys %$filtered) {
		next if $$mapping{$part};
		my $origkey= $$filtered{$part};
		$$mapping{$part}=$$mapping{$origkey}
	    }
	};
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   split /_/ }
			   keys %$mapping);
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   /([a-z]+)/g }
			   keys %$mapping);
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   /(\d+)/g }
			   keys %$mapping);
    }
    my $key= lc $rawkey;
    if (my $do= $$mapping{$key}) {
	&$do
    } else {
	local our $trie= new Tree::Trie;
	$trie->add_data ($_, $$mapping{$_}) for (keys %$mapping);

	# filter on values, thus reverse key/value pairs
	my $res= { $trie->lookup_data ($key) };
	if (keys %$res) {
	    my $val;
	    for my $k (keys %$res) {
		if ($val) {
		    if ($$res{$k} eq $val) {
			# ok
		    } else {
			Die "station key '$key' ambiguous";
		    }
		} else {
		    $val= $$res{$k}
		}
	    }
	    &$val
	} else {
	    Die "station key '$key' not found";
	}
    }
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
