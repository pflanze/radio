#!/usr/bin/perl -w

# Wed Jun 24 16:42:42 EDT 2009
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname radioname

  Instead of radionname, give -l to get listing of all known radionames.

  Radioname can be part of the key given in -l, split on the
  underscore or digit and alphabetic character parts, or prefixes
  thereof, as long as there's no conflict.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our ($opt_l,$opt_dry);
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "list"=>\$opt_l,
	   "dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==1 or $opt_l;
our ($rawkey)=@ARGV;

use Chj::xperlfunc ':all';

our $run=sub {
    our ($cmd,@args)=@_;
    xexec (@$cmd,@args)
};

our $mkplayer= sub {
    my ($player)=@_;
    sub ( $ ) {
	my ($url)=@_;
	sub {
	    &$run ([$player],$url)
	}
    }
};
our $mplayer= &$mkplayer ("mplayer");
our $mp3= &$mkplayer ("mpg123");

#
#und lazy wär es klr gl."?"...schongeldoch .

our $mapping=
  +{
    #drs1=> [$mplayer, "mms://dms-cl-021.skypro-media.net/drs1"],
    #h und eben equivalenzhiernidgegebenhhhhhh,   so:
    drs1=> &$mplayer("mms://dms-cl-021.skypro-media.net/drs1"),
    #krck.
    drs2=> &$mplayer("mms://dms-cl-021.skypro-media.net/drs2"),
    drs3=> &$mplayer("mms://dms-cl-021.skypro-media.net/drs3"),
    drs_virus=> &$mplayer("mms://dms-cl-021.skypro-media.net/virus"),
    drs4=> &$mplayer ("mms://dms-cl-021.skypro-media.net/drs4"), # "drs4 News"
    drs_musikwelle=> &$mplayer("mms://dms-cl-021.skypro-media.net/mw531"),

    couleur3=> &$mp3("http://broadcast.infomaniak.net:8000/rsr-couleur3-high.mp3"), # http://kevin.denis.free.fr/tips/radio.html 'mplayer `lynx -dump http://real.xobix.ch/live/rsr3.ram | grep rtsp | head -1`'  hm geht nimmer aber das file actually contains 'http://broadcast.infomaniak.net:8000/rsr-couleur3-high.mp3' wow
    #hm h wer wohl da mp3 drusmacht"??"

   };

sub Die {
    die join("", "$myname: ",@_, "\n")
}

sub filter_singles ( $ ) { # array of pairs -> hash containing only those pairs which appear once
    # [ [ "a", 1 ], [ "a", 2 ], [ "b", 3 ] ] -> { "b" => 3 }
    my ($lis)=@_;
    my $seen= {};
    my $out;
    for (@$lis) {
	my ($key,$val)=@$_;
	if ($$seen{$key}) {
	    delete $$out{$key}; # in case we had something
	} else {
	    $$seen{$key}=1;
	    $$out{$key}=$val;
	}
    }
    $out
}
# sub filter_singles { # values -> values which appear only once  (ordering of values not maintained!)
#     my $seen= {};
#     my $out;
#     for my $key (@_) {
# 	if ($$seen{$key}) {
# 	    delete $$out{$key}; # in case we had something
# 	} else {
# 	    $$seen{$key}=1;
# 	    $$out{$key}=undef;
# 	}
#     }
#     keys %$out
# }
#use Chj::Backtrace; use Chj::repl; repl;
#__END__
if ($opt_l) {
    print map { "$_\n" } sort keys %$mapping
} else {
    use Data::Dumper;
    print Data::Dumper->Dump([$mapping],["mapping"]);
    {
	# first try to add the parts split on _, then split on number boundaries;
	# while never 'risking' random ordering. we order by running code so. order. and then filter so that no random overlay endings happen  jou understand?.
	local our $add_keys_singles= sub {
	    local our $filtered= filter_singles \@_;
	    #use Chj::Backtrace; use Chj::repl; repl;
	    print Data::Dumper->Dump([$filtered],["filtered"]);
	    for my $part (keys %$filtered) {
		next if $$mapping{$part};
		#my ($_partagain, $origkey)= @{ $$filtered{$part} };
		#nope how kam ich druf.  wurden nur einfach mehrfach reingegebn. origkey for every part. aber just origkey. list of lists is nur toplevel ding. das \@_.  heh.
		my $origkey= $$filtered{$part};
		$$mapping{$part}=$$mapping{$origkey}
	    }
	};
	#use Chj::Backtrace; use Chj::repl; repl;
	print "Adding split _..\n";
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   split /_/ }
			   keys %$mapping);
#use Chj::Backtrace; use Chj::repl; repl;
	print "Adding split [a-z]+..\n";

	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   /([a-z]+)/g }
			   keys %$mapping);
#use Chj::Backtrace; use Chj::repl; repl;
	print "Adding split \\d+..\n";

	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   /(\d+)/g }
			   keys %$mapping);
#use Chj::Backtrace; use Chj::repl; repl;

    }
    print Data::Dumper->Dump([$mapping],["mapping"]);
    my $key= lc $rawkey;
    if (my $do= $$mapping{$key}) {
	&$do
    } else {
	# search from beginning from string ok.?. how eff well we know well. hmh. tree eben auch wenn nur dings.
	# trie
	# well:
	#  Text::Trie  Text-Trie-0.21 - 09 Aug 1999 - Ilya Zakharevich
	#  Data::Trie  data-trie-0.01 - 09 Aug 2004 - Mike Hammond 
	#  Tree::Trie  Tree-Trie-1.5 - 19 Aug 2007 - Avi Finkel
	use Tree::Trie;
	local our $trie= new Tree::Trie;
	$trie->add_data ($_, $$mapping{$_}) for (keys %$mapping);

	my @res= $trie->lookup_data ($key);
	if (@res==2) {
	    &{$res[1]}
	} elsif (@res) {
	    Die "station key '$key' ambiguous";
	} else {
	    Die "station key '$key' not found";
	}
    }
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
