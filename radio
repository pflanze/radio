#!/usr/bin/perl -w

# Wed Jun 24 16:42:42 EDT 2009
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname radioname

  Instead of radionname, give -l to get listing of all known radionames.

  Radioname can be part of the key given in -l, split on the
  underscore or digit and alphabetic character parts, or prefixes
  thereof, as long as there's no conflict.

  Options:
  -l|--list  list known station keys
  --dry-run  only select station, don't open it

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our ($opt_l,$opt_dry);
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "list"=>\$opt_l,
	   "dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==1 or $opt_l;
our ($rawkey)=@ARGV;

use Chj::xperlfunc ':all';

our $run=sub {
    our ($cmd,@args)=@_;
    xexec (@$cmd,@args)
};

our $mkplayer= sub {
    my ($player,$maybe_playername)=@_;
    my $playername= $maybe_playername || $$player[0];
    sub ( $ ) {
	my ($key,$url)=@_;
	(lc($key),
	 sub {
	     if ($opt_dry) {
		 print "Would play $key ($url) with $playername.\n";
	     } else {
		 my $msg= "*** Playing $key ($url) with $playername ***";
		 my $line= "*"x(length($msg));
		 print "$line\n$msg\n$line\n";
		 &$run ($player,$url)
	     }
	 }
	)
    }
};
our $mplayer= &$mkplayer (["mplayer",
			   #"-audio-preload","2"  is in mplayer manpage, but is for mencoder only.
			   #hm finde nix
			  ]);
our $mp3= &$mkplayer (["mpg123"]);
our $ogg= &$mkplayer (["ogg123", "-b","100","-p","90"]);

#
#und lazy wär es klr gl."?"...schongeldoch .

our $mapping=
  +{
    #drs1=> [$mplayer, "mms://dms-cl-021.skypro-media.net/drs1"],
    #h und eben equivalenzhiernidgegebenhhhhhh,   so:
    &$mplayer(drs1=> "mms://dms-cl-021.skypro-media.net/drs1"),
    #krck.
    &$mplayer(drs2=> "mms://dms-cl-021.skypro-media.net/drs2"),
    &$mplayer(drs3=> "mms://dms-cl-021.skypro-media.net/drs3"),
    &$mplayer(drs_virus=> "mms://dms-cl-021.skypro-media.net/virus"),
    &$mplayer (drs4=> "mms://dms-cl-021.skypro-media.net/drs4"), # "drs4 News"
    &$mplayer(drs_musikwelle=> "mms://dms-cl-021.skypro-media.net/mw531"),

    &$mp3(couleur3=> "http://broadcast.infomaniak.net:8000/rsr-couleur3-high.mp3"), # http://kevin.denis.free.fr/tips/radio.html 'mplayer `lynx -dump http://real.xobix.ch/live/rsr3.ram | grep rtsp | head -1`'  hm geht nimmer aber das file actually contains 'http://broadcast.infomaniak.net:8000/rsr-couleur3-high.mp3' wow
    #hm h wer wohl da mp3 drusmacht"??"

    # http://en.wikipedia.org/wiki/CKRK-FM
    # English-language Canadian radio station located in Kahnawake, Quebec, a Mohawk Indian reserve near Montreal
    #  103.7 MHz, ~220 watts
    # http://www.k103radio.com/newversion/index.php
    # http://knw-stream.mohawk.ca:8000/k103.m3u
    &$mp3 ("montreal_k103_CKRK-FM"=> "http://knw-stream.mohawk.ca:8000/k103"),

    &$mp3 (montreal_CIBL=> "http://stream02.ustream.ca:8000/cibl128.mp3"),

    # http://en.wikipedia.org/wiki/CKUT-FM
    # the official campus community radio station of McGill University
    # 90.3 FM in Montreal, 91.7 on cable
    # broadcast from a tower on the top of Mount Royal, reaches as far as the Eastern Townships and upstate New York
    # 5.6 kW
    # more than 300 volunteers
    &$ogg (montreal_ckut=> "http://www.ckut.ca:8000/ckut-live.ogg"),

    &$mp3 (dnaradio_dnalounge=> "http://cerebrum.dnalounge.com:8000/radio"),
    &$mp3 (zinzine=> "http://213.251.135.149:8000/radio-zinzine-live"),
    &$ogg (radius=> "http://relay.radio.ethz.ch/sender.ogg"),
    &$mp3 (radius_mp3=> "http://relay.radio.ethz.ch/sender.mp3"),
    &$mp3 (localhost=> "http://localhost:1234/"),

    # http://en.wikipedia.org/wiki/CJLM-FM
    # located in Joliette
    # www.m1035fm.com   M 103,5 FM - La radio du Grand Lanaudière
    # "http://205.151.16.92:8000/xstream.m3u"
    &$mp3 ("CJLM-FM_joliette"=> "http://205.151.16.92:8000/xstream"),
   };

sub Die {
    die join("", "$myname: ",@_, "\n")
}

sub filter_singles ( $ ) { # array of pairs -> hash containing only those pairs which appear once
    # [ [ "a", 1 ], [ "a", 2 ], [ "b", 3 ] ] -> { "b" => 3 }
    my ($lis)=@_;
    my $seen= {};
    my $out= {};
    for (@$lis) {
	my ($key,$val)=@$_;
	if ($$seen{$key}) {
	    delete $$out{$key}; # in case we had something
	} else {
	    $$seen{$key}=1;
	    $$out{$key}=$val;
	}
    }
    $out
}

# sub uniq ( $ ) { # array of pairs -> hash containing only those pairs which appear once, *except* if the values are the same, then include one copy. WEll, if it's not the same, just die, rather.
#     # [ [ "a", 1 ], [ "a", 1 ], [ "b", 3 ] ] -> { "a"=> 1, "b" => 3 }
#     my ($lis)=@_;
#     my $out={};
#     for (@$lis) {
# 	my ($key,$val)=@$_;
# 	if (exists $$out{$key}) {
# 	    if ($$out{$key} eq $val) {
# 		# ok
# 	    } else {
# 		die "multiple different values for key '$key'";
# 	    }
# 	} else {
# 	    $$out{$key}=$val;
# 	}
#     }
#     $out
# }

#need to map key=>val  with same val  to   val=> [ keys ]   hm.  ach strip it.


# sub filter_singles { # values -> values which appear only once  (ordering of values not maintained!)
#     my $seen= {};
#     my $out;
#     for my $key (@_) {
# 	if ($$seen{$key}) {
# 	    delete $$out{$key}; # in case we had something
# 	} else {
# 	    $$seen{$key}=1;
# 	    $$out{$key}=undef;
# 	}
#     }
#     keys %$out
# }
#use Chj::Backtrace; use Chj::repl; repl;
#__END__
if ($opt_l) {
    print map { "$_\n" } sort keys %$mapping
} else {
    {
	# first try to add the parts split on _, then split on number boundaries;
	# while never 'risking' random ordering. we order by running code so. order. and then filter so that no random overlay endings happen  jou understand?.
	local our $add_keys_singles= sub {
	    local our $filtered= filter_singles \@_;
	    for my $part (keys %$filtered) {
		next if $$mapping{$part};
		#my ($_partagain, $origkey)= @{ $$filtered{$part} };
		#nope how kam ich druf.  wurden nur einfach mehrfach reingegebn. origkey for every part. aber just origkey. list of lists is nur toplevel ding. das \@_.  heh.
		my $origkey= $$filtered{$part};
		$$mapping{$part}=$$mapping{$origkey}
	    }
	};
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   split /_/ }
			   keys %$mapping);
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   /([a-z]+)/g }
			   keys %$mapping);
	&$add_keys_singles(map { my $key= $_;
				 map { [$_, $key] }
				   /(\d+)/g }
			   keys %$mapping);
    }
    my $key= lc $rawkey;
    if (my $do= $$mapping{$key}) {
	&$do
    } else {
	# search from beginning from string ok.?. how eff well we know well. hmh. tree eben auch wenn nur dings.
	# trie
	# well:
	#  Text::Trie  Text-Trie-0.21 - 09 Aug 1999 - Ilya Zakharevich
	#  Data::Trie  data-trie-0.01 - 09 Aug 2004 - Mike Hammond 
	#  Tree::Trie  Tree-Trie-1.5 - 19 Aug 2007 - Avi Finkel
	use Tree::Trie;
	local our $trie= new Tree::Trie;
	$trie->add_data ($_, $$mapping{$_}) for (keys %$mapping);

	# filter on values, thus reverse key/value pairs
	# take in hash to create pairs at all.(sgh) (can't reverse here, since we would loose the complex values)
	my $res= { $trie->lookup_data ($key) };
	#(see uniq code above but then need something else, just forget and hand code) (shit perl hashes ohne key keeping)
	# all the values have to be the same
	if (keys %$res) {
	    my $val;
	    for my $k (keys %$res) {
		if ($val) {
		    if ($$res{$k} eq $val) {
			# ok
		    } else {
			Die "station key '$key' ambiguous";
		    }
		} else {
		    $val= $$res{$k}
		}
	    }
	    &$val
	      #'so einfach wars'.wl.
	} else {
	    Die "station key '$key' not found";
	}
    }
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
